"use strict";
// tslint:disable
/**
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.youneedabudget.com
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const url = require("url");
// Requiring portable-fetch like this ensures that we have a global fetch function
// That makes it easier to override with modules like fetch-mock
require("portable-fetch");
const USER_AGENT = "api_client/js/1.0.0";
function convertDateToFullDateStringFormat(date) {
    // Convert to RFC 3339 "full-date" format, like "2017-11-27"
    if (date instanceof Date) {
        return date.toISOString().substring(0, 10);
    }
    else {
        return date;
    }
}
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace Account
 */
var Account;
(function (Account) {
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Checking"] = 'checking'] = "Checking";
        TypeEnum[TypeEnum["Savings"] = 'savings'] = "Savings";
        TypeEnum[TypeEnum["Cash"] = 'cash'] = "Cash";
        TypeEnum[TypeEnum["CreditCard"] = 'creditCard'] = "CreditCard";
        TypeEnum[TypeEnum["LineOfCredit"] = 'lineOfCredit'] = "LineOfCredit";
        TypeEnum[TypeEnum["OtherAsset"] = 'otherAsset'] = "OtherAsset";
        TypeEnum[TypeEnum["OtherLiability"] = 'otherLiability'] = "OtherLiability";
        TypeEnum[TypeEnum["PayPal"] = 'payPal'] = "PayPal";
        TypeEnum[TypeEnum["MerchantAccount"] = 'merchantAccount'] = "MerchantAccount";
        TypeEnum[TypeEnum["InvestmentAccount"] = 'investmentAccount'] = "InvestmentAccount";
        TypeEnum[TypeEnum["Mortgage"] = 'mortgage'] = "Mortgage";
    })(TypeEnum = Account.TypeEnum || (Account.TypeEnum = {}));
})(Account = exports.Account || (exports.Account = {}));
/**
 * @export
 * @namespace SaveTransaction
 */
var SaveTransaction;
(function (SaveTransaction) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = SaveTransaction.ClearedEnum || (SaveTransaction.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = SaveTransaction.FlagColorEnum || (SaveTransaction.FlagColorEnum = {}));
})(SaveTransaction = exports.SaveTransaction || (exports.SaveTransaction = {}));
/**
 * @export
 * @namespace ScheduledTransactionSummary
 */
var ScheduledTransactionSummary;
(function (ScheduledTransactionSummary) {
    /**
     * @export
     * @enum {string}
     */
    let FrequencyEnum;
    (function (FrequencyEnum) {
        FrequencyEnum[FrequencyEnum["Never"] = 'never'] = "Never";
        FrequencyEnum[FrequencyEnum["Daily"] = 'daily'] = "Daily";
        FrequencyEnum[FrequencyEnum["Weekly"] = 'weekly'] = "Weekly";
        FrequencyEnum[FrequencyEnum["EveryOtherWeek"] = 'everyOtherWeek'] = "EveryOtherWeek";
        FrequencyEnum[FrequencyEnum["TwiceAMonth"] = 'twiceAMonth'] = "TwiceAMonth";
        FrequencyEnum[FrequencyEnum["Every4Weeks"] = 'every4Weeks'] = "Every4Weeks";
        FrequencyEnum[FrequencyEnum["Monthly"] = 'monthly'] = "Monthly";
        FrequencyEnum[FrequencyEnum["EveryOtherMonth"] = 'everyOtherMonth'] = "EveryOtherMonth";
        FrequencyEnum[FrequencyEnum["Every3Months"] = 'every3Months'] = "Every3Months";
        FrequencyEnum[FrequencyEnum["Every4Months"] = 'every4Months'] = "Every4Months";
        FrequencyEnum[FrequencyEnum["TwiceAYear"] = 'twiceAYear'] = "TwiceAYear";
        FrequencyEnum[FrequencyEnum["Yearly"] = 'yearly'] = "Yearly";
        FrequencyEnum[FrequencyEnum["EveryOtherYear"] = 'everyOtherYear'] = "EveryOtherYear";
    })(FrequencyEnum = ScheduledTransactionSummary.FrequencyEnum || (ScheduledTransactionSummary.FrequencyEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = ScheduledTransactionSummary.FlagColorEnum || (ScheduledTransactionSummary.FlagColorEnum = {}));
})(ScheduledTransactionSummary = exports.ScheduledTransactionSummary || (exports.ScheduledTransactionSummary = {}));
/**
 * @export
 * @namespace TransactionSummary
 */
var TransactionSummary;
(function (TransactionSummary) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = TransactionSummary.ClearedEnum || (TransactionSummary.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = TransactionSummary.FlagColorEnum || (TransactionSummary.FlagColorEnum = {}));
})(TransactionSummary = exports.TransactionSummary || (exports.TransactionSummary = {}));
/**
 * @export
 * @namespace HybridTransaction
 */
var HybridTransaction;
(function (HybridTransaction) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = HybridTransaction.ClearedEnum || (HybridTransaction.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = HybridTransaction.FlagColorEnum || (HybridTransaction.FlagColorEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TypeEnum;
    (function (TypeEnum) {
        TypeEnum[TypeEnum["Transaction"] = 'transaction'] = "Transaction";
        TypeEnum[TypeEnum["Subtransaction"] = 'subtransaction'] = "Subtransaction";
    })(TypeEnum = HybridTransaction.TypeEnum || (HybridTransaction.TypeEnum = {}));
})(HybridTransaction = exports.HybridTransaction || (exports.HybridTransaction = {}));
/**
 * @export
 * @namespace ScheduledTransactionDetail
 */
var ScheduledTransactionDetail;
(function (ScheduledTransactionDetail) {
    /**
     * @export
     * @enum {string}
     */
    let FrequencyEnum;
    (function (FrequencyEnum) {
        FrequencyEnum[FrequencyEnum["Never"] = 'never'] = "Never";
        FrequencyEnum[FrequencyEnum["Daily"] = 'daily'] = "Daily";
        FrequencyEnum[FrequencyEnum["Weekly"] = 'weekly'] = "Weekly";
        FrequencyEnum[FrequencyEnum["EveryOtherWeek"] = 'everyOtherWeek'] = "EveryOtherWeek";
        FrequencyEnum[FrequencyEnum["TwiceAMonth"] = 'twiceAMonth'] = "TwiceAMonth";
        FrequencyEnum[FrequencyEnum["Every4Weeks"] = 'every4Weeks'] = "Every4Weeks";
        FrequencyEnum[FrequencyEnum["Monthly"] = 'monthly'] = "Monthly";
        FrequencyEnum[FrequencyEnum["EveryOtherMonth"] = 'everyOtherMonth'] = "EveryOtherMonth";
        FrequencyEnum[FrequencyEnum["Every3Months"] = 'every3Months'] = "Every3Months";
        FrequencyEnum[FrequencyEnum["Every4Months"] = 'every4Months'] = "Every4Months";
        FrequencyEnum[FrequencyEnum["TwiceAYear"] = 'twiceAYear'] = "TwiceAYear";
        FrequencyEnum[FrequencyEnum["Yearly"] = 'yearly'] = "Yearly";
        FrequencyEnum[FrequencyEnum["EveryOtherYear"] = 'everyOtherYear'] = "EveryOtherYear";
    })(FrequencyEnum = ScheduledTransactionDetail.FrequencyEnum || (ScheduledTransactionDetail.FrequencyEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = ScheduledTransactionDetail.FlagColorEnum || (ScheduledTransactionDetail.FlagColorEnum = {}));
})(ScheduledTransactionDetail = exports.ScheduledTransactionDetail || (exports.ScheduledTransactionDetail = {}));
/**
 * @export
 * @namespace TransactionDetail
 */
var TransactionDetail;
(function (TransactionDetail) {
    /**
     * @export
     * @enum {string}
     */
    let ClearedEnum;
    (function (ClearedEnum) {
        ClearedEnum[ClearedEnum["Cleared"] = 'cleared'] = "Cleared";
        ClearedEnum[ClearedEnum["Uncleared"] = 'uncleared'] = "Uncleared";
        ClearedEnum[ClearedEnum["Reconciled"] = 'reconciled'] = "Reconciled";
    })(ClearedEnum = TransactionDetail.ClearedEnum || (TransactionDetail.ClearedEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let FlagColorEnum;
    (function (FlagColorEnum) {
        FlagColorEnum[FlagColorEnum["Red"] = 'red'] = "Red";
        FlagColorEnum[FlagColorEnum["Orange"] = 'orange'] = "Orange";
        FlagColorEnum[FlagColorEnum["Yellow"] = 'yellow'] = "Yellow";
        FlagColorEnum[FlagColorEnum["Green"] = 'green'] = "Green";
        FlagColorEnum[FlagColorEnum["Blue"] = 'blue'] = "Blue";
        FlagColorEnum[FlagColorEnum["Purple"] = 'purple'] = "Purple";
    })(FlagColorEnum = TransactionDetail.FlagColorEnum || (TransactionDetail.FlagColorEnum = {}));
})(TransactionDetail = exports.TransactionDetail || (exports.TransactionDetail = {}));
/**
 * AccountsApi - fetch parameter creator
 * @export
 */
exports.AccountsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id, account_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getAccountById.');
            }
            // verify required parameter 'account_id' is not null or undefined
            if (account_id === null || account_id === undefined) {
                throw new RequiredError('account_id', 'Required parameter account_id was null or undefined when calling getAccountById.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(account_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountsApi - functional programming interface
 * @export
 */
exports.AccountsApiFp = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id, account_id, options) {
            const localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).getAccountById(budget_id, account_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id, options) {
            const localVarFetchArgs = exports.AccountsApiFetchParamCreator(configuration).getAccounts(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * AccountsApi - factory interface
 * @export
 */
exports.AccountsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id, account_id, options) {
            return exports.AccountsApiFp(configuration).getAccountById(budget_id, account_id, options)();
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id, options) {
            return exports.AccountsApiFp(configuration).getAccounts(budget_id, options)();
        },
    };
};
/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
class AccountsApi extends BaseAPI {
    /**
     * Returns a single account
     * @summary Single account
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} account_id - The ID of the Account.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccountById(budget_id, account_id, options) {
        return exports.AccountsApiFp(this.configuration).getAccountById(budget_id, account_id, options)();
    }
    /**
     * Returns all accounts
     * @summary Account list
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    getAccounts(budget_id, options) {
        return exports.AccountsApiFp(this.configuration).getAccounts(budget_id, options)();
    }
}
exports.AccountsApi = AccountsApi;
/**
 * BudgetsApi - fetch parameter creator
 * @export
 */
exports.BudgetsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The ID of the Budget.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id, last_knowledge_of_server, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetById.');
            }
            const localVarPath = `/budgets/{budget_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns settings for a budget.
         * @summary Budget Settings
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetSettingsById.');
            }
            const localVarPath = `/budgets/{budget_id}/settings`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budgets list with summary information.
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options = {}) {
            const localVarPath = `/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BudgetsApi - functional programming interface
 * @export
 */
exports.BudgetsApiFp = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The ID of the Budget.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id, last_knowledge_of_server, options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgetById(budget_id, last_knowledge_of_server, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns settings for a budget.
         * @summary Budget Settings
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budget_id, options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgetSettingsById(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budgets list with summary information.
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options) {
            const localVarFetchArgs = exports.BudgetsApiFetchParamCreator(configuration).getBudgets(options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * BudgetsApi - factory interface
 * @export
 */
exports.BudgetsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The ID of the Budget.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id, last_knowledge_of_server, options) {
            return exports.BudgetsApiFp(configuration).getBudgetById(budget_id, last_knowledge_of_server, options)();
        },
        /**
         * Returns settings for a budget.
         * @summary Budget Settings
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetSettingsById(budget_id, options) {
            return exports.BudgetsApiFp(configuration).getBudgetSettingsById(budget_id, options)();
        },
        /**
         * Returns budgets list with summary information.
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options) {
            return exports.BudgetsApiFp(configuration).getBudgets(options)();
        },
    };
};
/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
class BudgetsApi extends BaseAPI {
    /**
     * Returns a single budget with all related entities.  This resource is effectively a full budget export.
     * @summary Single budget
     * @param {string} budget_id - The ID of the Budget.
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgetById(budget_id, last_knowledge_of_server, options) {
        return exports.BudgetsApiFp(this.configuration).getBudgetById(budget_id, last_knowledge_of_server, options)();
    }
    /**
     * Returns settings for a budget.
     * @summary Budget Settings
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgetSettingsById(budget_id, options) {
        return exports.BudgetsApiFp(this.configuration).getBudgetSettingsById(budget_id, options)();
    }
    /**
     * Returns budgets list with summary information.
     * @summary List budgets
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    getBudgets(options) {
        return exports.BudgetsApiFp(this.configuration).getBudgets(options)();
    }
}
exports.BudgetsApi = BudgetsApi;
/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
exports.CategoriesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group.
         * @summary List categories
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getCategories.');
            }
            const localVarPath = `/budgets/{budget_id}/categories`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id, category_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getCategoryById.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id', 'Required parameter category_id was null or undefined when calling getCategoryById.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CategoriesApi - functional programming interface
 * @export
 */
exports.CategoriesApiFp = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group.
         * @summary List categories
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getCategories(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id, category_id, options) {
            const localVarFetchArgs = exports.CategoriesApiFetchParamCreator(configuration).getCategoryById(budget_id, category_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * CategoriesApi - factory interface
 * @export
 */
exports.CategoriesApiFactory = function (configuration) {
    return {
        /**
         * Returns all categories grouped by category group.
         * @summary List categories
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id, options) {
            return exports.CategoriesApiFp(configuration).getCategories(budget_id, options)();
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id, category_id, options) {
            return exports.CategoriesApiFp(configuration).getCategoryById(budget_id, category_id, options)();
        },
    };
};
/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
class CategoriesApi extends BaseAPI {
    /**
     * Returns all categories grouped by category group.
     * @summary List categories
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategories(budget_id, options) {
        return exports.CategoriesApiFp(this.configuration).getCategories(budget_id, options)();
    }
    /**
     * Returns a single category
     * @summary Single category
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} category_id - The ID of the Category.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    getCategoryById(budget_id, category_id, options) {
        return exports.CategoriesApiFp(this.configuration).getCategoryById(budget_id, category_id, options)();
    }
}
exports.CategoriesApi = CategoriesApi;
/**
 * MonthsApi - fetch parameter creator
 * @export
 */
exports.MonthsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id, month, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetMonth.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month', 'Required parameter month was null or undefined when calling getBudgetMonth.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getBudgetMonths.');
            }
            const localVarPath = `/budgets/{budget_id}/months`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MonthsApi - functional programming interface
 * @export
 */
exports.MonthsApiFp = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id, month, options) {
            const localVarFetchArgs = exports.MonthsApiFetchParamCreator(configuration).getBudgetMonth(budget_id, month, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id, options) {
            const localVarFetchArgs = exports.MonthsApiFetchParamCreator(configuration).getBudgetMonths(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * MonthsApi - factory interface
 * @export
 */
exports.MonthsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id, month, options) {
            return exports.MonthsApiFp(configuration).getBudgetMonth(budget_id, month, options)();
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id, options) {
            return exports.MonthsApiFp(configuration).getBudgetMonths(budget_id, options)();
        },
    };
};
/**
 * MonthsApi - object-oriented interface
 * @export
 * @class MonthsApi
 * @extends {BaseAPI}
 */
class MonthsApi extends BaseAPI {
    /**
     * Returns a single budget month
     * @summary Single budget month
     * @param {string} budget_id - The ID of the Budget.
     * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    getBudgetMonth(budget_id, month, options) {
        return exports.MonthsApiFp(this.configuration).getBudgetMonth(budget_id, month, options)();
    }
    /**
     * Returns all budget months
     * @summary List budget months
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    getBudgetMonths(budget_id, options) {
        return exports.MonthsApiFp(this.configuration).getBudgetMonths(budget_id, options)();
    }
}
exports.MonthsApi = MonthsApi;
/**
 * PayeeLocationsApi - fetch parameter creator
 * @export
 */
exports.PayeeLocationsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_location_id - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id, payee_location_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeLocationById.');
            }
            // verify required parameter 'payee_location_id' is not null or undefined
            if (payee_location_id === null || payee_location_id === undefined) {
                throw new RequiredError('payee_location_id', 'Required parameter payee_location_id was null or undefined when calling getPayeeLocationById.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations/{payee_location_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_location_id"}}`, encodeURIComponent(String(payee_location_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeLocations.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id, payee_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeLocationsByPayee.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id', 'Required parameter payee_id was null or undefined when calling getPayeeLocationsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PayeeLocationsApi - functional programming interface
 * @export
 */
exports.PayeeLocationsApiFp = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_location_id - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id, payee_location_id, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationById(budget_id, payee_location_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocations(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id, payee_id, options) {
            const localVarFetchArgs = exports.PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationsByPayee(budget_id, payee_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * PayeeLocationsApi - factory interface
 * @export
 */
exports.PayeeLocationsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_location_id - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id, payee_location_id, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocationById(budget_id, payee_location_id, options)();
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocations(budget_id, options)();
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id, payee_id, options) {
            return exports.PayeeLocationsApiFp(configuration).getPayeeLocationsByPayee(budget_id, payee_id, options)();
        },
    };
};
/**
 * PayeeLocationsApi - object-oriented interface
 * @export
 * @class PayeeLocationsApi
 * @extends {BaseAPI}
 */
class PayeeLocationsApi extends BaseAPI {
    /**
     * Returns a single payee location
     * @summary Single payee location
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_location_id - ID of payee location
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocationById(budget_id, payee_location_id, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocationById(budget_id, payee_location_id, options)();
    }
    /**
     * Returns all payee locations
     * @summary List payee locations
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocations(budget_id, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocations(budget_id, options)();
    }
    /**
     * Returns all payee locations for the specified payee
     * @summary List locations for a payee
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_id - ID of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    getPayeeLocationsByPayee(budget_id, payee_id, options) {
        return exports.PayeeLocationsApiFp(this.configuration).getPayeeLocationsByPayee(budget_id, payee_id, options)();
    }
}
exports.PayeeLocationsApi = PayeeLocationsApi;
/**
 * PayeesApi - fetch parameter creator
 * @export
 */
exports.PayeesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id, payee_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayeeById.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id', 'Required parameter payee_id was null or undefined when calling getPayeeById.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getPayees.');
            }
            const localVarPath = `/budgets/{budget_id}/payees`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PayeesApi - functional programming interface
 * @export
 */
exports.PayeesApiFp = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id, payee_id, options) {
            const localVarFetchArgs = exports.PayeesApiFetchParamCreator(configuration).getPayeeById(budget_id, payee_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id, options) {
            const localVarFetchArgs = exports.PayeesApiFetchParamCreator(configuration).getPayees(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * PayeesApi - factory interface
 * @export
 */
exports.PayeesApiFactory = function (configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id, payee_id, options) {
            return exports.PayeesApiFp(configuration).getPayeeById(budget_id, payee_id, options)();
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id, options) {
            return exports.PayeesApiFp(configuration).getPayees(budget_id, options)();
        },
    };
};
/**
 * PayeesApi - object-oriented interface
 * @export
 * @class PayeesApi
 * @extends {BaseAPI}
 */
class PayeesApi extends BaseAPI {
    /**
     * Returns single payee
     * @summary Single payee
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_id - The ID of the Payee.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    getPayeeById(budget_id, payee_id, options) {
        return exports.PayeesApiFp(this.configuration).getPayeeById(budget_id, payee_id, options)();
    }
    /**
     * Returns all payees
     * @summary List payees
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    getPayees(budget_id, options) {
        return exports.PayeesApiFp(this.configuration).getPayees(budget_id, options)();
    }
}
exports.PayeesApi = PayeesApi;
/**
 * ScheduledTransactionsApi - fetch parameter creator
 * @export
 */
exports.ScheduledTransactionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id, scheduled_transaction_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getScheduledTransactionById.');
            }
            // verify required parameter 'scheduled_transaction_id' is not null or undefined
            if (scheduled_transaction_id === null || scheduled_transaction_id === undefined) {
                throw new RequiredError('scheduled_transaction_id', 'Required parameter scheduled_transaction_id was null or undefined when calling getScheduledTransactionById.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions/{scheduled_transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"scheduled_transaction_id"}}`, encodeURIComponent(String(scheduled_transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getScheduledTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ScheduledTransactionsApi - functional programming interface
 * @export
 */
exports.ScheduledTransactionsApiFp = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id, scheduled_transaction_id, options) {
            const localVarFetchArgs = exports.ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id, options) {
            const localVarFetchArgs = exports.ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactions(budget_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * ScheduledTransactionsApi - factory interface
 * @export
 */
exports.ScheduledTransactionsApiFactory = function (configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id, scheduled_transaction_id, options) {
            return exports.ScheduledTransactionsApiFp(configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options)();
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id, options) {
            return exports.ScheduledTransactionsApiFp(configuration).getScheduledTransactions(budget_id, options)();
        },
    };
};
/**
 * ScheduledTransactionsApi - object-oriented interface
 * @export
 * @class ScheduledTransactionsApi
 * @extends {BaseAPI}
 */
class ScheduledTransactionsApi extends BaseAPI {
    /**
     * Returns a single scheduled transaction
     * @summary Single scheduled transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    getScheduledTransactionById(budget_id, scheduled_transaction_id, options) {
        return exports.ScheduledTransactionsApiFp(this.configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options)();
    }
    /**
     * Returns all scheduled transactions
     * @summary List scheduled transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    getScheduledTransactions(budget_id, options) {
        return exports.ScheduledTransactionsApiFp(this.configuration).getScheduledTransactions(budget_id, options)();
    }
}
exports.ScheduledTransactionsApi = ScheduledTransactionsApi;
/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
exports.TransactionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Creates multiple transactions
         * @summary Bulk create transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {BulkTransactions} transactions - The list of Transactions to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id, transactions, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling bulkCreateTransactions.');
            }
            // verify required parameter 'transactions' is not null or undefined
            if (transactions === null || transactions === undefined) {
                throw new RequiredError('transactions', 'Required parameter transactions was null or undefined when calling bulkCreateTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/bulk`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transactions || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a transaction
         * @summary Create new transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {SaveTransactionWrapper} transaction - The Transaction to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id, transaction, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling createTransaction.');
            }
            // verify required parameter 'transaction' is not null or undefined
            if (transaction === null || transaction === undefined) {
                throw new RequiredError('transaction', 'Required parameter transaction was null or undefined when calling createTransaction.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transaction || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type ('uncategorized' and 'unapproved' are currently supported)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id, since_date, type, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id, account_id, since_date, type, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsByAccount.');
            }
            // verify required parameter 'account_id' is not null or undefined
            if (account_id === null || account_id === undefined) {
                throw new RequiredError('account_id', 'Required parameter account_id was null or undefined when calling getTransactionsByAccount.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(account_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id, category_id, since_date, type, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsByCategory.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id', 'Required parameter category_id was null or undefined when calling getTransactionsByCategory.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budget_id, transaction_id, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsById.');
            }
            // verify required parameter 'transaction_id' is not null or undefined
            if (transaction_id === null || transaction_id === undefined) {
                throw new RequiredError('transaction_id', 'Required parameter transaction_id was null or undefined when calling getTransactionsById.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id, payee_id, since_date, type, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling getTransactionsByPayee.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id', 'Required parameter payee_id was null or undefined when calling getTransactionsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {SaveTransactionWrapper} transaction - The Transaction to update.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id, transaction_id, transaction, options = {}) {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id', 'Required parameter budget_id was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'transaction_id' is not null or undefined
            if (transaction_id === null || transaction_id === undefined) {
                throw new RequiredError('transaction_id', 'Required parameter transaction_id was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'transaction' is not null or undefined
            if (transaction === null || transaction === undefined) {
                throw new RequiredError('transaction', 'Required parameter transaction was null or undefined when calling updateTransaction.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transaction || {});
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionsApi - functional programming interface
 * @export
 */
exports.TransactionsApiFp = function (configuration) {
    return {
        /**
         * Creates multiple transactions
         * @summary Bulk create transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {BulkTransactions} transactions - The list of Transactions to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id, transactions, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).bulkCreateTransactions(budget_id, transactions, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Creates a transaction
         * @summary Create new transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {SaveTransactionWrapper} transaction - The Transaction to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id, transaction, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).createTransaction(budget_id, transaction, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type ('uncategorized' and 'unapproved' are currently supported)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id, since_date, type, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactions(budget_id, since_date, type, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id, account_id, since_date, type, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByAccount(budget_id, account_id, since_date, type, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id, category_id, since_date, type, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByCategory(budget_id, category_id, since_date, type, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budget_id, transaction_id, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsById(budget_id, transaction_id, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id, payee_id, since_date, type, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).getTransactionsByPayee(budget_id, payee_id, since_date, type, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {SaveTransactionWrapper} transaction - The Transaction to update.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id, transaction_id, transaction, options) {
            const localVarFetchArgs = exports.TransactionsApiFetchParamCreator(configuration).updateTransaction(budget_id, transaction_id, transaction, options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * TransactionsApi - factory interface
 * @export
 */
exports.TransactionsApiFactory = function (configuration) {
    return {
        /**
         * Creates multiple transactions
         * @summary Bulk create transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {BulkTransactions} transactions - The list of Transactions to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id, transactions, options) {
            return exports.TransactionsApiFp(configuration).bulkCreateTransactions(budget_id, transactions, options)();
        },
        /**
         * Creates a transaction
         * @summary Create new transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {SaveTransactionWrapper} transaction - The Transaction to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id, transaction, options) {
            return exports.TransactionsApiFp(configuration).createTransaction(budget_id, transaction, options)();
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type ('uncategorized' and 'unapproved' are currently supported)
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id, since_date, type, options) {
            return exports.TransactionsApiFp(configuration).getTransactions(budget_id, since_date, type, options)();
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id, account_id, since_date, type, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByAccount(budget_id, account_id, since_date, type, options)();
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id, category_id, since_date, type, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByCategory(budget_id, category_id, since_date, type, options)();
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budget_id, transaction_id, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsById(budget_id, transaction_id, options)();
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id, payee_id, since_date, type, options) {
            return exports.TransactionsApiFp(configuration).getTransactionsByPayee(budget_id, payee_id, since_date, type, options)();
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {SaveTransactionWrapper} transaction - The Transaction to update.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id, transaction_id, transaction, options) {
            return exports.TransactionsApiFp(configuration).updateTransaction(budget_id, transaction_id, transaction, options)();
        },
    };
};
/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
class TransactionsApi extends BaseAPI {
    /**
     * Creates multiple transactions
     * @summary Bulk create transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {BulkTransactions} transactions - The list of Transactions to create.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    bulkCreateTransactions(budget_id, transactions, options) {
        return exports.TransactionsApiFp(this.configuration).bulkCreateTransactions(budget_id, transactions, options)();
    }
    /**
     * Creates a transaction
     * @summary Create new transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {SaveTransactionWrapper} transaction - The Transaction to create.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    createTransaction(budget_id, transaction, options) {
        return exports.TransactionsApiFp(this.configuration).createTransaction(budget_id, transaction, options)();
    }
    /**
     * Returns budget transactions
     * @summary List transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type ('uncategorized' and 'unapproved' are currently supported)
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactions(budget_id, since_date, type, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactions(budget_id, since_date, type, options)();
    }
    /**
     * Returns all transactions for a specified account
     * @summary List account transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} account_id - The ID of the Account.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByAccount(budget_id, account_id, since_date, type, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByAccount(budget_id, account_id, since_date, type, options)();
    }
    /**
     * Returns all transactions for a specified category
     * @summary List category transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} category_id - The ID of the Category.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByCategory(budget_id, category_id, since_date, type, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByCategory(budget_id, category_id, since_date, type, options)();
    }
    /**
     * Returns a single transaction
     * @summary Single transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} transaction_id - The ID of the Transaction.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsById(budget_id, transaction_id, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsById(budget_id, transaction_id, options)();
    }
    /**
     * Returns all transactions for a specified payee
     * @summary List payee transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_id - The ID of the Payee.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {&#39;uncategorized&#39; | &#39;unapproved&#39;} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    getTransactionsByPayee(budget_id, payee_id, since_date, type, options) {
        return exports.TransactionsApiFp(this.configuration).getTransactionsByPayee(budget_id, payee_id, since_date, type, options)();
    }
    /**
     * Updates a transaction
     * @summary Updates an existing transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} transaction_id - The ID of the Transaction.
     * @param {SaveTransactionWrapper} transaction - The Transaction to update.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    updateTransaction(budget_id, transaction_id, transaction, options) {
        return exports.TransactionsApiFp(this.configuration).updateTransaction(budget_id, transaction_id, transaction, options)();
    }
}
exports.TransactionsApi = TransactionsApi;
/**
 * UserApi - fetch parameter creator
 * @export
 */
exports.UserApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Returns authenticated user information.
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options = {}) {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";
            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserApi - functional programming interface
 * @export
 */
exports.UserApiFp = function (configuration) {
    return {
        /**
         * Returns authenticated user information.
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options) {
            const localVarFetchArgs = exports.UserApiFetchParamCreator(configuration).getUser(options);
            return (fetchFunction = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    };
};
/**
 * UserApi - factory interface
 * @export
 */
exports.UserApiFactory = function (configuration) {
    return {
        /**
         * Returns authenticated user information.
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options) {
            return exports.UserApiFp(configuration).getUser(options)();
        },
    };
};
/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
class UserApi extends BaseAPI {
    /**
     * Returns authenticated user information.
     * @summary User info
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    getUser(options) {
        return exports.UserApiFp(this.configuration).getUser(options)();
    }
}
exports.UserApi = UserApi;
