// tslint:disable
/**
 * YNAB API Endpoints
 * Our API uses a REST based design, leverages the JSON data format, and relies upon HTTPS for transport. We respond with meaningful HTTP response codes and if an error occurs, we include error details in the response body.  API Documentation is at https://api.youneedabudget.com
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
// Requiring portable-fetch like this ensures that we have a global fetch function
// That makes it easier to override with modules like fetch-mock
require("portable-fetch");

import { Configuration } from "./configuration";

const USER_AGENT = "api_client/js/0.14.0";

function convertDateToFullDateStringFormat(date: Date | string): string {
  // Convert to RFC 3339 "full-date" format, like "2017-11-27"
  if (date instanceof Date) {
    return date.toISOString().substring(0, 10);
  } else {
    return date;
  }
}

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    type: Account.TypeEnum;
    /**
     * Whether this account is on budget or not
     * @type {boolean}
     * @memberof Account
     */
    on_budget: boolean;
    /**
     * Whether this account is closed or not
     * @type {boolean}
     * @memberof Account
     */
    closed: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    note: string;
    /**
     * The current balance of the account in milliunits format
     * @type {number}
     * @memberof Account
     */
    balance: number;
    /**
     * The current cleared balance of the account in milliunits format
     * @type {number}
     * @memberof Account
     */
    cleared_balance: number;
    /**
     * The current uncleared balance of the account in milliunits format
     * @type {number}
     * @memberof Account
     */
    uncleared_balance: number;
}

/**
 * @export
 * @namespace Account
 */
export namespace Account {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Checking = <any> 'checking',
        Savings = <any> 'savings',
        CreditCard = <any> 'creditCard',
        Cash = <any> 'cash',
        LineOfCredit = <any> 'lineOfCredit',
        MerchantAccount = <any> 'merchantAccount',
        PayPal = <any> 'payPal',
        InvestmentAccount = <any> 'investmentAccount',
        Mortgage = <any> 'mortgage',
        OtherAsset = <any> 'otherAsset',
        OtherLiability = <any> 'otherLiability'
    }
}

/**
 * 
 * @export
 * @interface AccountResponse
 */
export interface AccountResponse {
    /**
     * 
     * @type {AccountWrapper}
     * @memberof AccountResponse
     */
    data: AccountWrapper;
}

/**
 * 
 * @export
 * @interface AccountWrapper
 */
export interface AccountWrapper {
    /**
     * 
     * @type {Account}
     * @memberof AccountWrapper
     */
    account: Account;
}

/**
 * 
 * @export
 * @interface AccountsResponse
 */
export interface AccountsResponse {
    /**
     * 
     * @type {AccountsWrapper}
     * @memberof AccountsResponse
     */
    data: AccountsWrapper;
}

/**
 * 
 * @export
 * @interface AccountsWrapper
 */
export interface AccountsWrapper {
    /**
     * 
     * @type {Array&lt;Account&gt;}
     * @memberof AccountsWrapper
     */
    accounts: Array<Account>;
}

/**
 * 
 * @export
 * @interface BudgetDetailResponse
 */
export interface BudgetDetailResponse {
    /**
     * 
     * @type {BudgetDetailWrapper}
     * @memberof BudgetDetailResponse
     */
    data: BudgetDetailWrapper;
}

/**
 * 
 * @export
 * @interface BudgetDetailWrapper
 */
export interface BudgetDetailWrapper {
    /**
     * 
     * @type {BudgetDetail}
     * @memberof BudgetDetailWrapper
     */
    budget: BudgetDetail;
    /**
     * The knowledge of the server
     * @type {number}
     * @memberof BudgetDetailWrapper
     */
    server_knowledge: number;
}

/**
 * 
 * @export
 * @interface BudgetSummary
 */
export interface BudgetSummary {
    /**
     * 
     * @type {string}
     * @memberof BudgetSummary
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetSummary
     */
    name: string;
    /**
     * The last time any changes were made to the budget from either a web or mobile client.
     * @type {string}
     * @memberof BudgetSummary
     */
    last_modified_on?: string;
    /**
     * 
     * @type {DateFormat}
     * @memberof BudgetSummary
     */
    date_format?: DateFormat;
    /**
     * 
     * @type {CurrencyFormat}
     * @memberof BudgetSummary
     */
    currency_format?: CurrencyFormat;
}

/**
 * 
 * @export
 * @interface BudgetSummaryResponse
 */
export interface BudgetSummaryResponse {
    /**
     * 
     * @type {BudgetSummaryWrapper}
     * @memberof BudgetSummaryResponse
     */
    data: BudgetSummaryWrapper;
}

/**
 * 
 * @export
 * @interface BudgetSummaryWrapper
 */
export interface BudgetSummaryWrapper {
    /**
     * 
     * @type {Array&lt;BudgetSummary&gt;}
     * @memberof BudgetSummaryWrapper
     */
    budgets: Array<BudgetSummary>;
}

/**
 * 
 * @export
 * @interface BulkIdWrapper
 */
export interface BulkIdWrapper {
    /**
     * 
     * @type {BulkIds}
     * @memberof BulkIdWrapper
     */
    bulk: BulkIds;
}

/**
 * 
 * @export
 * @interface BulkIds
 */
export interface BulkIds {
    /**
     * The list of Transaction IDs that were created.
     * @type {Array&lt;string&gt;}
     * @memberof BulkIds
     */
    transaction_ids: Array<string>;
    /**
     * If any Transactions were not created because they had an import_id matching a transaction already on the same account, the specified import_id(s) will be included in this list.
     * @type {Array&lt;string&gt;}
     * @memberof BulkIds
     */
    duplicate_import_ids: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkResponse
 */
export interface BulkResponse {
    /**
     * 
     * @type {BulkIdWrapper}
     * @memberof BulkResponse
     */
    data: BulkIdWrapper;
}

/**
 * 
 * @export
 * @interface BulkTransactions
 */
export interface BulkTransactions {
    /**
     * 
     * @type {Array&lt;SaveTransaction&gt;}
     * @memberof BulkTransactions
     */
    transactions: Array<SaveTransaction>;
}

/**
 * 
 * @export
 * @interface CategoriesResponse
 */
export interface CategoriesResponse {
    /**
     * 
     * @type {CategoryGroupsWrapper}
     * @memberof CategoriesResponse
     */
    data: CategoryGroupsWrapper;
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    category_group_id: string;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * Whether or not the category is hidden
     * @type {boolean}
     * @memberof Category
     */
    hidden: boolean;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    note: string;
    /**
     * Budgeted amount in current month in milliunits format
     * @type {number}
     * @memberof Category
     */
    budgeted: number;
    /**
     * Activity amount in current month in milliunits format
     * @type {number}
     * @memberof Category
     */
    activity: number;
    /**
     * Balance in current month in milliunits format
     * @type {number}
     * @memberof Category
     */
    balance: number;
}

/**
 * 
 * @export
 * @interface CategoryGroup
 */
export interface CategoryGroup {
    /**
     * 
     * @type {string}
     * @memberof CategoryGroup
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryGroup
     */
    name: string;
    /**
     * Whether or not the category group is hidden
     * @type {boolean}
     * @memberof CategoryGroup
     */
    hidden: boolean;
}

/**
 * 
 * @export
 * @interface CategoryGroupsWrapper
 */
export interface CategoryGroupsWrapper {
    /**
     * 
     * @type {Array&lt;CategoryGroupWithCategories&gt;}
     * @memberof CategoryGroupsWrapper
     */
    category_groups: Array<CategoryGroupWithCategories>;
}

/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * 
     * @type {CategoryWrapper}
     * @memberof CategoryResponse
     */
    data: CategoryWrapper;
}

/**
 * 
 * @export
 * @interface CategoryWrapper
 */
export interface CategoryWrapper {
    /**
     * 
     * @type {Category}
     * @memberof CategoryWrapper
     */
    category: Category;
}

/**
 * 
 * @export
 * @interface CurrencyFormat
 */
export interface CurrencyFormat {
    /**
     * 
     * @type {string}
     * @memberof CurrencyFormat
     */
    locale: string;
}

/**
 * 
 * @export
 * @interface DateFormat
 */
export interface DateFormat {
    /**
     * 
     * @type {string}
     * @memberof DateFormat
     */
    locale: string;
}

/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    detail: string;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorDetail}
     * @memberof ErrorResponse
     */
    error: ErrorDetail;
}

/**
 * 
 * @export
 * @interface HybridTransactionsResponse
 */
export interface HybridTransactionsResponse {
    /**
     * 
     * @type {HybridTransactionsWrapper}
     * @memberof HybridTransactionsResponse
     */
    data: HybridTransactionsWrapper;
}

/**
 * 
 * @export
 * @interface HybridTransactionsWrapper
 */
export interface HybridTransactionsWrapper {
    /**
     * 
     * @type {Array&lt;HybridTransaction&gt;}
     * @memberof HybridTransactionsWrapper
     */
    transactions: Array<HybridTransaction>;
}

/**
 * 
 * @export
 * @interface MonthDetailResponse
 */
export interface MonthDetailResponse {
    /**
     * 
     * @type {MonthDetailWrapper}
     * @memberof MonthDetailResponse
     */
    data: MonthDetailWrapper;
}

/**
 * 
 * @export
 * @interface MonthDetailWrapper
 */
export interface MonthDetailWrapper {
    /**
     * 
     * @type {MonthDetail}
     * @memberof MonthDetailWrapper
     */
    month: MonthDetail;
}

/**
 * 
 * @export
 * @interface MonthSummariesResponse
 */
export interface MonthSummariesResponse {
    /**
     * 
     * @type {MonthSummariesWrapper}
     * @memberof MonthSummariesResponse
     */
    data: MonthSummariesWrapper;
}

/**
 * 
 * @export
 * @interface MonthSummariesWrapper
 */
export interface MonthSummariesWrapper {
    /**
     * 
     * @type {Array&lt;MonthSummary&gt;}
     * @memberof MonthSummariesWrapper
     */
    months: Array<MonthSummary>;
}

/**
 * 
 * @export
 * @interface MonthSummary
 */
export interface MonthSummary {
    /**
     * 
     * @type {string}
     * @memberof MonthSummary
     */
    month: string;
    /**
     * 
     * @type {string}
     * @memberof MonthSummary
     */
    note: string;
    /**
     * The current balance of the account in milliunits format
     * @type {number}
     * @memberof MonthSummary
     */
    to_be_budgeted: number;
    /**
     * 
     * @type {number}
     * @memberof MonthSummary
     */
    age_of_money: number;
}

/**
 * 
 * @export
 * @interface Payee
 */
export interface Payee {
    /**
     * 
     * @type {string}
     * @memberof Payee
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Payee
     */
    name: string;
    /**
     * If a transfer payee, the account_id to which this payee transfers to
     * @type {string}
     * @memberof Payee
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface PayeeLocation
 */
export interface PayeeLocation {
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    latitude: string;
    /**
     * 
     * @type {string}
     * @memberof PayeeLocation
     */
    longitude: string;
}

/**
 * 
 * @export
 * @interface PayeeLocationResponse
 */
export interface PayeeLocationResponse {
    /**
     * 
     * @type {PayeeLocationWrapper}
     * @memberof PayeeLocationResponse
     */
    data: PayeeLocationWrapper;
}

/**
 * 
 * @export
 * @interface PayeeLocationWrapper
 */
export interface PayeeLocationWrapper {
    /**
     * 
     * @type {PayeeLocation}
     * @memberof PayeeLocationWrapper
     */
    payee_location: PayeeLocation;
}

/**
 * 
 * @export
 * @interface PayeeLocationsResponse
 */
export interface PayeeLocationsResponse {
    /**
     * 
     * @type {PayeeLocationsWrapper}
     * @memberof PayeeLocationsResponse
     */
    data: PayeeLocationsWrapper;
}

/**
 * 
 * @export
 * @interface PayeeLocationsWrapper
 */
export interface PayeeLocationsWrapper {
    /**
     * 
     * @type {Array&lt;PayeeLocation&gt;}
     * @memberof PayeeLocationsWrapper
     */
    payee_locations: Array<PayeeLocation>;
}

/**
 * 
 * @export
 * @interface PayeeResponse
 */
export interface PayeeResponse {
    /**
     * 
     * @type {PayeeWrapper}
     * @memberof PayeeResponse
     */
    data: PayeeWrapper;
}

/**
 * 
 * @export
 * @interface PayeeWrapper
 */
export interface PayeeWrapper {
    /**
     * 
     * @type {Payee}
     * @memberof PayeeWrapper
     */
    payee: Payee;
}

/**
 * 
 * @export
 * @interface PayeesResponse
 */
export interface PayeesResponse {
    /**
     * 
     * @type {PayeesWrapper}
     * @memberof PayeesResponse
     */
    data: PayeesWrapper;
}

/**
 * 
 * @export
 * @interface PayeesWrapper
 */
export interface PayeesWrapper {
    /**
     * 
     * @type {Array&lt;Payee&gt;}
     * @memberof PayeesWrapper
     */
    payees: Array<Payee>;
}

/**
 * 
 * @export
 * @interface SaveTransaction
 */
export interface SaveTransaction {
    /**
     * 
     * @type {string}
     * @memberof SaveTransaction
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof SaveTransaction
     */
    date: string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof SaveTransaction
     */
    amount: number;
    /**
     * The payee for the transaction.  Transfer payees are not permitted and will be ignored if supplied.
     * @type {string}
     * @memberof SaveTransaction
     */
    payee_id?: string;
    /**
     * The payee name.  If a payee_name value is provided and payee_id is not included or has a null value, payee_name will be used to create or use an existing payee.
     * @type {string}
     * @memberof SaveTransaction
     */
    payee_name?: string;
    /**
     * The category for the transaction.  Split and Credit Card Payment categories are not permitted and will be ignored if supplied.
     * @type {string}
     * @memberof SaveTransaction
     */
    category_id?: string;
    /**
     * 
     * @type {string}
     * @memberof SaveTransaction
     */
    memo?: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof SaveTransaction
     */
    cleared?: SaveTransaction.ClearedEnum;
    /**
     * Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.
     * @type {boolean}
     * @memberof SaveTransaction
     */
    approved?: boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof SaveTransaction
     */
    flag_color?: SaveTransaction.FlagColorEnum;
    /**
     * If specified for a new transaction, the transaction will be treated as Imported and assigned this import_id.  If another transaction on the same account with this same import_id is later attempted to be created, it will be skipped to prevent duplication.  Transactions imported through File Based Import or Direct Import and not through the API, are assigned an import_id in the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.  If import_id is specified as null, the transaction will be treated as a user entered transaction.
     * @type {string}
     * @memberof SaveTransaction
     */
    import_id?: string;
}

/**
 * @export
 * @namespace SaveTransaction
 */
export namespace SaveTransaction {
    /**
     * @export
     * @enum {string}
     */
    export enum ClearedEnum {
        Cleared = <any> 'cleared',
        Uncleared = <any> 'uncleared',
        Reconciled = <any> 'reconciled'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FlagColorEnum {
        Red = <any> 'red',
        Orange = <any> 'orange',
        Yellow = <any> 'yellow',
        Green = <any> 'green',
        Blue = <any> 'blue',
        Purple = <any> 'purple'
    }
}

/**
 * 
 * @export
 * @interface SaveTransactionWrapper
 */
export interface SaveTransactionWrapper {
    /**
     * 
     * @type {SaveTransaction}
     * @memberof SaveTransactionWrapper
     */
    transaction: SaveTransaction;
}

/**
 * 
 * @export
 * @interface ScheduledSubTransaction
 */
export interface ScheduledSubTransaction {
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    scheduled_transaction_id: string;
    /**
     * The scheduled subtransaction amount in milliunits format
     * @type {number}
     * @memberof ScheduledSubTransaction
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the scheduled sub transaction transfers to
     * @type {string}
     * @memberof ScheduledSubTransaction
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionResponse
 */
export interface ScheduledTransactionResponse {
    /**
     * 
     * @type {ScheduledTransactionWrapper}
     * @memberof ScheduledTransactionResponse
     */
    data: ScheduledTransactionWrapper;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionSummary
 */
export interface ScheduledTransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    id: string;
    /**
     * The first date for which the Scheduled Transaction was scheduled.
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    date_first: string;
    /**
     * The next date for which the Scheduled Transaction is scheduled.
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    date_next: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    frequency: ScheduledTransactionSummary.FrequencyEnum;
    /**
     * The scheduled transaction amount in milliunits format
     * @type {number}
     * @memberof ScheduledTransactionSummary
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    memo: string;
    /**
     * The scheduled transaction flag
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    flag_color: ScheduledTransactionSummary.FlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the scheduled transaction transfers to
     * @type {string}
     * @memberof ScheduledTransactionSummary
     */
    transfer_account_id: string;
}

/**
 * @export
 * @namespace ScheduledTransactionSummary
 */
export namespace ScheduledTransactionSummary {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        Never = <any> 'never',
        Daily = <any> 'daily',
        Weekly = <any> 'weekly',
        EveryOtherWeek = <any> 'everyOtherWeek',
        TwiceAMonth = <any> 'twiceAMonth',
        Every4Weeks = <any> 'every4Weeks',
        Monthly = <any> 'monthly',
        EveryOtherMonth = <any> 'everyOtherMonth',
        Every3Months = <any> 'every3Months',
        Every4Months = <any> 'every4Months',
        TwiceAYear = <any> 'twiceAYear',
        Yearly = <any> 'yearly',
        EveryOtherYear = <any> 'everyOtherYear'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FlagColorEnum {
        Red = <any> 'red',
        Orange = <any> 'orange',
        Yellow = <any> 'yellow',
        Green = <any> 'green',
        Blue = <any> 'blue',
        Purple = <any> 'purple'
    }
}

/**
 * 
 * @export
 * @interface ScheduledTransactionWrapper
 */
export interface ScheduledTransactionWrapper {
    /**
     * 
     * @type {ScheduledTransactionDetail}
     * @memberof ScheduledTransactionWrapper
     */
    scheduled_transaction: ScheduledTransactionDetail;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionsResponse
 */
export interface ScheduledTransactionsResponse {
    /**
     * 
     * @type {ScheduledTransactionsWrapper}
     * @memberof ScheduledTransactionsResponse
     */
    data: ScheduledTransactionsWrapper;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionsWrapper
 */
export interface ScheduledTransactionsWrapper {
    /**
     * 
     * @type {Array&lt;ScheduledTransactionDetail&gt;}
     * @memberof ScheduledTransactionsWrapper
     */
    scheduled_transactions: Array<ScheduledTransactionDetail>;
}

/**
 * 
 * @export
 * @interface SubTransaction
 */
export interface SubTransaction {
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    transaction_id: string;
    /**
     * The subtransaction amount in milliunits format
     * @type {number}
     * @memberof SubTransaction
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    memo: string;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof SubTransaction
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the subtransaction transfers to
     * @type {string}
     * @memberof SubTransaction
     */
    transfer_account_id: string;
}

/**
 * 
 * @export
 * @interface TransactionResponse
 */
export interface TransactionResponse {
    /**
     * 
     * @type {TransactionWrapper}
     * @memberof TransactionResponse
     */
    data: TransactionWrapper;
}

/**
 * 
 * @export
 * @interface TransactionSummary
 */
export interface TransactionSummary {
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    date: string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof TransactionSummary
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    memo: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof TransactionSummary
     */
    cleared: TransactionSummary.ClearedEnum;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof TransactionSummary
     */
    approved: boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof TransactionSummary
     */
    flag_color: TransactionSummary.FlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    category_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSummary
     */
    transfer_account_id: string;
    /**
     * If the Transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
     * @type {string}
     * @memberof TransactionSummary
     */
    import_id: string;
}

/**
 * @export
 * @namespace TransactionSummary
 */
export namespace TransactionSummary {
    /**
     * @export
     * @enum {string}
     */
    export enum ClearedEnum {
        Cleared = <any> 'cleared',
        Uncleared = <any> 'uncleared',
        Reconciled = <any> 'reconciled'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FlagColorEnum {
        Red = <any> 'red',
        Orange = <any> 'orange',
        Yellow = <any> 'yellow',
        Green = <any> 'green',
        Blue = <any> 'blue',
        Purple = <any> 'purple'
    }
}

/**
 * 
 * @export
 * @interface TransactionWrapper
 */
export interface TransactionWrapper {
    /**
     * 
     * @type {TransactionDetail}
     * @memberof TransactionWrapper
     */
    transaction: TransactionDetail;
}

/**
 * 
 * @export
 * @interface TransactionsResponse
 */
export interface TransactionsResponse {
    /**
     * 
     * @type {TransactionsWrapper}
     * @memberof TransactionsResponse
     */
    data: TransactionsWrapper;
}

/**
 * 
 * @export
 * @interface TransactionsWrapper
 */
export interface TransactionsWrapper {
    /**
     * 
     * @type {Array&lt;TransactionDetail&gt;}
     * @memberof TransactionsWrapper
     */
    transactions: Array<TransactionDetail>;
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id: string;
}

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {UserWrapper}
     * @memberof UserResponse
     */
    data: UserWrapper;
}

/**
 * 
 * @export
 * @interface UserWrapper
 */
export interface UserWrapper {
    /**
     * 
     * @type {User}
     * @memberof UserWrapper
     */
    user: User;
}

/**
 * 
 * @export
 * @interface BudgetDetail
 */
export interface BudgetDetail {
    /**
     * 
     * @type {string}
     * @memberof BudgetDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof BudgetDetail
     */
    name: string;
    /**
     * The last time any changes were made to the budget from either a web or mobile client.
     * @type {string}
     * @memberof BudgetDetail
     */
    last_modified_on?: string;
    /**
     * 
     * @type {DateFormat}
     * @memberof BudgetDetail
     */
    date_format?: DateFormat;
    /**
     * 
     * @type {CurrencyFormat}
     * @memberof BudgetDetail
     */
    currency_format?: CurrencyFormat;
    /**
     * 
     * @type {Array&lt;Account&gt;}
     * @memberof BudgetDetail
     */
    accounts?: Array<Account>;
    /**
     * 
     * @type {Array&lt;Payee&gt;}
     * @memberof BudgetDetail
     */
    payees?: Array<Payee>;
    /**
     * 
     * @type {Array&lt;PayeeLocation&gt;}
     * @memberof BudgetDetail
     */
    payee_locations?: Array<PayeeLocation>;
    /**
     * 
     * @type {Array&lt;CategoryGroup&gt;}
     * @memberof BudgetDetail
     */
    category_groups?: Array<CategoryGroup>;
    /**
     * 
     * @type {Array&lt;Category&gt;}
     * @memberof BudgetDetail
     */
    categories?: Array<Category>;
    /**
     * 
     * @type {Array&lt;MonthDetail&gt;}
     * @memberof BudgetDetail
     */
    months?: Array<MonthDetail>;
    /**
     * 
     * @type {Array&lt;TransactionSummary&gt;}
     * @memberof BudgetDetail
     */
    transactions?: Array<TransactionSummary>;
    /**
     * 
     * @type {Array&lt;SubTransaction&gt;}
     * @memberof BudgetDetail
     */
    subtransactions?: Array<SubTransaction>;
    /**
     * 
     * @type {Array&lt;ScheduledTransactionSummary&gt;}
     * @memberof BudgetDetail
     */
    scheduled_transactions?: Array<ScheduledTransactionSummary>;
    /**
     * 
     * @type {Array&lt;ScheduledSubTransaction&gt;}
     * @memberof BudgetDetail
     */
    scheduled_subtransactions?: Array<ScheduledSubTransaction>;
}

/**
 * 
 * @export
 * @interface CategoryGroupWithCategories
 */
export interface CategoryGroupWithCategories {
    /**
     * 
     * @type {string}
     * @memberof CategoryGroupWithCategories
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryGroupWithCategories
     */
    name: string;
    /**
     * Whether or not the category group is hidden
     * @type {boolean}
     * @memberof CategoryGroupWithCategories
     */
    hidden: boolean;
    /**
     * Category group categories
     * @type {Array&lt;Category&gt;}
     * @memberof CategoryGroupWithCategories
     */
    categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface HybridTransaction
 */
export interface HybridTransaction {
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    date: string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof HybridTransaction
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    memo: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof HybridTransaction
     */
    cleared: HybridTransaction.ClearedEnum;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof HybridTransaction
     */
    approved: boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof HybridTransaction
     */
    flag_color: HybridTransaction.FlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    category_id: string;
    /**
     * 
     * @type {string}
     * @memberof HybridTransaction
     */
    transfer_account_id: string;
    /**
     * If the Transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
     * @type {string}
     * @memberof HybridTransaction
     */
    import_id: string;
    /**
     * Whether the hybrid transaction represents a regular transaction or a subtransaction
     * @type {string}
     * @memberof HybridTransaction
     */
    type: HybridTransaction.TypeEnum;
    /**
     * For subtransaction types, this is the id of the pararent transaction.  For transaction types, this id will be always be null.
     * @type {string}
     * @memberof HybridTransaction
     */
    parent_transaction_id: string;
}

/**
 * @export
 * @namespace HybridTransaction
 */
export namespace HybridTransaction {
    /**
     * @export
     * @enum {string}
     */
    export enum ClearedEnum {
        Cleared = <any> 'cleared',
        Uncleared = <any> 'uncleared',
        Reconciled = <any> 'reconciled'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FlagColorEnum {
        Red = <any> 'red',
        Orange = <any> 'orange',
        Yellow = <any> 'yellow',
        Green = <any> 'green',
        Blue = <any> 'blue',
        Purple = <any> 'purple'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Transaction = <any> 'transaction',
        Subtransaction = <any> 'subtransaction'
    }
}

/**
 * 
 * @export
 * @interface MonthDetail
 */
export interface MonthDetail {
    /**
     * 
     * @type {string}
     * @memberof MonthDetail
     */
    month: string;
    /**
     * 
     * @type {string}
     * @memberof MonthDetail
     */
    note: string;
    /**
     * The current balance of the account in milliunits format
     * @type {number}
     * @memberof MonthDetail
     */
    to_be_budgeted: number;
    /**
     * 
     * @type {number}
     * @memberof MonthDetail
     */
    age_of_money: number;
    /**
     * The budget month categories
     * @type {Array&lt;Category&gt;}
     * @memberof MonthDetail
     */
    categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface ScheduledTransactionDetail
 */
export interface ScheduledTransactionDetail {
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    id: string;
    /**
     * The first date for which the Scheduled Transaction was scheduled.
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    date_first: string;
    /**
     * The next date for which the Scheduled Transaction is scheduled.
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    date_next: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    frequency: ScheduledTransactionDetail.FrequencyEnum;
    /**
     * The scheduled transaction amount in milliunits format
     * @type {number}
     * @memberof ScheduledTransactionDetail
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    memo: string;
    /**
     * The scheduled transaction flag
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    flag_color: ScheduledTransactionDetail.FlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    category_id: string;
    /**
     * If a transfer, the account_id which the scheduled transaction transfers to
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    transfer_account_id: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    account_name: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    payee_name: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduledTransactionDetail
     */
    category_name: string;
    /**
     * If a split scheduled transaction, the subtransactions.
     * @type {Array&lt;ScheduledSubTransaction&gt;}
     * @memberof ScheduledTransactionDetail
     */
    subtransactions: Array<ScheduledSubTransaction>;
}

/**
 * @export
 * @namespace ScheduledTransactionDetail
 */
export namespace ScheduledTransactionDetail {
    /**
     * @export
     * @enum {string}
     */
    export enum FrequencyEnum {
        Never = <any> 'never',
        Daily = <any> 'daily',
        Weekly = <any> 'weekly',
        EveryOtherWeek = <any> 'everyOtherWeek',
        TwiceAMonth = <any> 'twiceAMonth',
        Every4Weeks = <any> 'every4Weeks',
        Monthly = <any> 'monthly',
        EveryOtherMonth = <any> 'everyOtherMonth',
        Every3Months = <any> 'every3Months',
        Every4Months = <any> 'every4Months',
        TwiceAYear = <any> 'twiceAYear',
        Yearly = <any> 'yearly',
        EveryOtherYear = <any> 'everyOtherYear'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FlagColorEnum {
        Red = <any> 'red',
        Orange = <any> 'orange',
        Yellow = <any> 'yellow',
        Green = <any> 'green',
        Blue = <any> 'blue',
        Purple = <any> 'purple'
    }
}

/**
 * 
 * @export
 * @interface TransactionDetail
 */
export interface TransactionDetail {
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    date: string;
    /**
     * The transaction amount in milliunits format
     * @type {number}
     * @memberof TransactionDetail
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    memo: string;
    /**
     * The cleared status of the transaction
     * @type {string}
     * @memberof TransactionDetail
     */
    cleared: TransactionDetail.ClearedEnum;
    /**
     * Whether or not the transaction is approved
     * @type {boolean}
     * @memberof TransactionDetail
     */
    approved: boolean;
    /**
     * The transaction flag
     * @type {string}
     * @memberof TransactionDetail
     */
    flag_color: TransactionDetail.FlagColorEnum;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    account_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    payee_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    category_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    transfer_account_id: string;
    /**
     * If the Transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
     * @type {string}
     * @memberof TransactionDetail
     */
    import_id: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    account_name: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    payee_name: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionDetail
     */
    category_name: string;
    /**
     * If a split transaction, the subtransactions.
     * @type {Array&lt;SubTransaction&gt;}
     * @memberof TransactionDetail
     */
    subtransactions: Array<SubTransaction>;
}

/**
 * @export
 * @namespace TransactionDetail
 */
export namespace TransactionDetail {
    /**
     * @export
     * @enum {string}
     */
    export enum ClearedEnum {
        Cleared = <any> 'cleared',
        Uncleared = <any> 'uncleared',
        Reconciled = <any> 'reconciled'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum FlagColorEnum {
        Red = <any> 'red',
        Orange = <any> 'orange',
        Yellow = <any> 'yellow',
        Green = <any> 'green',
        Blue = <any> 'blue',
        Purple = <any> 'purple'
    }
}


/**
 * AccountsApi - fetch parameter creator
 * @export
 */
export const AccountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id: string, account_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getAccountById.');
            }
            // verify required parameter 'account_id' is not null or undefined
            if (account_id === null || account_id === undefined) {
                throw new RequiredError('account_id','Required parameter account_id was null or undefined when calling getAccountById.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(account_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getAccounts.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id: string, account_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<AccountResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccountById(budget_id, account_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<AccountsResponse> {
            const localVarFetchArgs = AccountsApiFetchParamCreator(configuration).getAccounts(budget_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single account
         * @summary Single account
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccountById(budget_id: string, account_id: string, options?: any) {
            return AccountsApiFp(configuration).getAccountById(budget_id, account_id, options)();
        },
        /**
         * Returns all accounts
         * @summary Account list
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getAccounts(budget_id: string, options?: any) {
            return AccountsApiFp(configuration).getAccounts(budget_id, options)();
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Returns a single account
     * @summary Single account
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} account_id - The ID of the Account.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountById(budget_id: string, account_id: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccountById(budget_id, account_id, options)();
    }

    /**
     * Returns all accounts
     * @summary Account list
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(budget_id: string, options?: any) {
        return AccountsApiFp(this.configuration).getAccounts(budget_id, options)();
    }

}

/**
 * BudgetsApi - fetch parameter creator
 * @export
 */
export const BudgetsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The ID of the Budget.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id: string, last_knowledge_of_server?: number, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getBudgetById.');
            }
            const localVarPath = `/budgets/{budget_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (last_knowledge_of_server !== undefined) {
                localVarQueryParameter['last_knowledge_of_server'] = last_knowledge_of_server;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budgets list with summary information.
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options: any = {}): FetchArgs {
            const localVarPath = `/budgets`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BudgetsApi - functional programming interface
 * @export
 */
export const BudgetsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The ID of the Budget.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id: string, last_knowledge_of_server?: number, options?: any): (fetchFunction?: FetchAPI) => Promise<BudgetDetailResponse> {
            const localVarFetchArgs = BudgetsApiFetchParamCreator(configuration).getBudgetById(budget_id, last_knowledge_of_server, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budgets list with summary information.
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options?: any): (fetchFunction?: FetchAPI) => Promise<BudgetSummaryResponse> {
            const localVarFetchArgs = BudgetsApiFetchParamCreator(configuration).getBudgets(options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * BudgetsApi - factory interface
 * @export
 */
export const BudgetsApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single budget with all related entities.  This resource is effectively a full budget export.
         * @summary Single budget
         * @param {string} budget_id - The ID of the Budget.
         * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetById(budget_id: string, last_knowledge_of_server?: number, options?: any) {
            return BudgetsApiFp(configuration).getBudgetById(budget_id, last_knowledge_of_server, options)();
        },
        /**
         * Returns budgets list with summary information.
         * @summary List budgets
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgets(options?: any) {
            return BudgetsApiFp(configuration).getBudgets(options)();
        },
    };
};

/**
 * BudgetsApi - object-oriented interface
 * @export
 * @class BudgetsApi
 * @extends {BaseAPI}
 */
export class BudgetsApi extends BaseAPI {
    /**
     * Returns a single budget with all related entities.  This resource is effectively a full budget export.
     * @summary Single budget
     * @param {string} budget_id - The ID of the Budget.
     * @param {number} [last_knowledge_of_server] - The starting server knowledge.  If provided, only entities that have changed since last_knowledge_of_server will be included.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgetById(budget_id: string, last_knowledge_of_server?: number, options?: any) {
        return BudgetsApiFp(this.configuration).getBudgetById(budget_id, last_knowledge_of_server, options)();
    }

    /**
     * Returns budgets list with summary information.
     * @summary List budgets
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof BudgetsApi
     */
    public getBudgets(options?: any) {
        return BudgetsApiFp(this.configuration).getBudgets(options)();
    }

}

/**
 * CategoriesApi - fetch parameter creator
 * @export
 */
export const CategoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all categories grouped by category group.
         * @summary List categories
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getCategories.');
            }
            const localVarPath = `/budgets/{budget_id}/categories`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id: string, category_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getCategoryById.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id','Required parameter category_id was null or undefined when calling getCategoryById.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns all categories grouped by category group.
         * @summary List categories
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<CategoriesResponse> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategories(budget_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id: string, category_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<CategoryResponse> {
            const localVarFetchArgs = CategoriesApiFetchParamCreator(configuration).getCategoryById(budget_id, category_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns all categories grouped by category group.
         * @summary List categories
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategories(budget_id: string, options?: any) {
            return CategoriesApiFp(configuration).getCategories(budget_id, options)();
        },
        /**
         * Returns a single category
         * @summary Single category
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getCategoryById(budget_id: string, category_id: string, options?: any) {
            return CategoriesApiFp(configuration).getCategoryById(budget_id, category_id, options)();
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Returns all categories grouped by category group.
     * @summary List categories
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategories(budget_id: string, options?: any) {
        return CategoriesApiFp(this.configuration).getCategories(budget_id, options)();
    }

    /**
     * Returns a single category
     * @summary Single category
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} category_id - The ID of the Category.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoryById(budget_id: string, category_id: string, options?: any) {
        return CategoriesApiFp(this.configuration).getCategoryById(budget_id, category_id, options)();
    }

}

/**
 * MonthsApi - fetch parameter creator
 * @export
 */
export const MonthsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id: string, month: Date | string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getBudgetMonth.');
            }
            // verify required parameter 'month' is not null or undefined
            if (month === null || month === undefined) {
                throw new RequiredError('month','Required parameter month was null or undefined when calling getBudgetMonth.');
            }
            const localVarPath = `/budgets/{budget_id}/months/{month}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"month"}}`, encodeURIComponent(convertDateToFullDateStringFormat(month)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getBudgetMonths.');
            }
            const localVarPath = `/budgets/{budget_id}/months`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MonthsApi - functional programming interface
 * @export
 */
export const MonthsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id: string, month: Date | string, options?: any): (fetchFunction?: FetchAPI) => Promise<MonthDetailResponse> {
            const localVarFetchArgs = MonthsApiFetchParamCreator(configuration).getBudgetMonth(budget_id, month, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<MonthSummariesResponse> {
            const localVarFetchArgs = MonthsApiFetchParamCreator(configuration).getBudgetMonths(budget_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * MonthsApi - factory interface
 * @export
 */
export const MonthsApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single budget month
         * @summary Single budget month
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonth(budget_id: string, month: Date | string, options?: any) {
            return MonthsApiFp(configuration).getBudgetMonth(budget_id, month, options)();
        },
        /**
         * Returns all budget months
         * @summary List budget months
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getBudgetMonths(budget_id: string, options?: any) {
            return MonthsApiFp(configuration).getBudgetMonths(budget_id, options)();
        },
    };
};

/**
 * MonthsApi - object-oriented interface
 * @export
 * @class MonthsApi
 * @extends {BaseAPI}
 */
export class MonthsApi extends BaseAPI {
    /**
     * Returns a single budget month
     * @summary Single budget month
     * @param {string} budget_id - The ID of the Budget.
     * @param {Date} month - The Budget Month.  \"current\" can also be used to specify the current calendar month (UTC).
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    public getBudgetMonth(budget_id: string, month: Date | string, options?: any) {
        return MonthsApiFp(this.configuration).getBudgetMonth(budget_id, month, options)();
    }

    /**
     * Returns all budget months
     * @summary List budget months
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof MonthsApi
     */
    public getBudgetMonths(budget_id: string, options?: any) {
        return MonthsApiFp(this.configuration).getBudgetMonths(budget_id, options)();
    }

}

/**
 * PayeeLocationsApi - fetch parameter creator
 * @export
 */
export const PayeeLocationsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_location_id - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id: string, payee_location_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getPayeeLocationById.');
            }
            // verify required parameter 'payee_location_id' is not null or undefined
            if (payee_location_id === null || payee_location_id === undefined) {
                throw new RequiredError('payee_location_id','Required parameter payee_location_id was null or undefined when calling getPayeeLocationById.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations/{payee_location_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_location_id"}}`, encodeURIComponent(String(payee_location_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getPayeeLocations.');
            }
            const localVarPath = `/budgets/{budget_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id: string, payee_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getPayeeLocationsByPayee.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id','Required parameter payee_id was null or undefined when calling getPayeeLocationsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/payee_locations`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayeeLocationsApi - functional programming interface
 * @export
 */
export const PayeeLocationsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_location_id - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id: string, payee_location_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<PayeeLocationResponse> {
            const localVarFetchArgs = PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationById(budget_id, payee_location_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<PayeeLocationsResponse> {
            const localVarFetchArgs = PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocations(budget_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id: string, payee_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<PayeeLocationsResponse> {
            const localVarFetchArgs = PayeeLocationsApiFetchParamCreator(configuration).getPayeeLocationsByPayee(budget_id, payee_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * PayeeLocationsApi - factory interface
 * @export
 */
export const PayeeLocationsApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single payee location
         * @summary Single payee location
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_location_id - ID of payee location
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationById(budget_id: string, payee_location_id: string, options?: any) {
            return PayeeLocationsApiFp(configuration).getPayeeLocationById(budget_id, payee_location_id, options)();
        },
        /**
         * Returns all payee locations
         * @summary List payee locations
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocations(budget_id: string, options?: any) {
            return PayeeLocationsApiFp(configuration).getPayeeLocations(budget_id, options)();
        },
        /**
         * Returns all payee locations for the specified payee
         * @summary List locations for a payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - ID of payee
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeLocationsByPayee(budget_id: string, payee_id: string, options?: any) {
            return PayeeLocationsApiFp(configuration).getPayeeLocationsByPayee(budget_id, payee_id, options)();
        },
    };
};

/**
 * PayeeLocationsApi - object-oriented interface
 * @export
 * @class PayeeLocationsApi
 * @extends {BaseAPI}
 */
export class PayeeLocationsApi extends BaseAPI {
    /**
     * Returns a single payee location
     * @summary Single payee location
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_location_id - ID of payee location
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocationById(budget_id: string, payee_location_id: string, options?: any) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocationById(budget_id, payee_location_id, options)();
    }

    /**
     * Returns all payee locations
     * @summary List payee locations
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocations(budget_id: string, options?: any) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocations(budget_id, options)();
    }

    /**
     * Returns all payee locations for the specified payee
     * @summary List locations for a payee
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_id - ID of payee
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeeLocationsApi
     */
    public getPayeeLocationsByPayee(budget_id: string, payee_id: string, options?: any) {
        return PayeeLocationsApiFp(this.configuration).getPayeeLocationsByPayee(budget_id, payee_id, options)();
    }

}

/**
 * PayeesApi - fetch parameter creator
 * @export
 */
export const PayeesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id: string, payee_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getPayeeById.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id','Required parameter payee_id was null or undefined when calling getPayeeById.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getPayees.');
            }
            const localVarPath = `/budgets/{budget_id}/payees`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PayeesApi - functional programming interface
 * @export
 */
export const PayeesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id: string, payee_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<PayeeResponse> {
            const localVarFetchArgs = PayeesApiFetchParamCreator(configuration).getPayeeById(budget_id, payee_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<PayeesResponse> {
            const localVarFetchArgs = PayeesApiFetchParamCreator(configuration).getPayees(budget_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * PayeesApi - factory interface
 * @export
 */
export const PayeesApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns single payee
         * @summary Single payee
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayeeById(budget_id: string, payee_id: string, options?: any) {
            return PayeesApiFp(configuration).getPayeeById(budget_id, payee_id, options)();
        },
        /**
         * Returns all payees
         * @summary List payees
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getPayees(budget_id: string, options?: any) {
            return PayeesApiFp(configuration).getPayees(budget_id, options)();
        },
    };
};

/**
 * PayeesApi - object-oriented interface
 * @export
 * @class PayeesApi
 * @extends {BaseAPI}
 */
export class PayeesApi extends BaseAPI {
    /**
     * Returns single payee
     * @summary Single payee
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_id - The ID of the Payee.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    public getPayeeById(budget_id: string, payee_id: string, options?: any) {
        return PayeesApiFp(this.configuration).getPayeeById(budget_id, payee_id, options)();
    }

    /**
     * Returns all payees
     * @summary List payees
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof PayeesApi
     */
    public getPayees(budget_id: string, options?: any) {
        return PayeesApiFp(this.configuration).getPayees(budget_id, options)();
    }

}

/**
 * ScheduledTransactionsApi - fetch parameter creator
 * @export
 */
export const ScheduledTransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id: string, scheduled_transaction_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getScheduledTransactionById.');
            }
            // verify required parameter 'scheduled_transaction_id' is not null or undefined
            if (scheduled_transaction_id === null || scheduled_transaction_id === undefined) {
                throw new RequiredError('scheduled_transaction_id','Required parameter scheduled_transaction_id was null or undefined when calling getScheduledTransactionById.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions/{scheduled_transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"scheduled_transaction_id"}}`, encodeURIComponent(String(scheduled_transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getScheduledTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/scheduled_transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduledTransactionsApi - functional programming interface
 * @export
 */
export const ScheduledTransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id: string, scheduled_transaction_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<ScheduledTransactionResponse> {
            const localVarFetchArgs = ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<ScheduledTransactionsResponse> {
            const localVarFetchArgs = ScheduledTransactionsApiFetchParamCreator(configuration).getScheduledTransactions(budget_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * ScheduledTransactionsApi - factory interface
 * @export
 */
export const ScheduledTransactionsApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single scheduled transaction
         * @summary Single scheduled transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactionById(budget_id: string, scheduled_transaction_id: string, options?: any) {
            return ScheduledTransactionsApiFp(configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options)();
        },
        /**
         * Returns all scheduled transactions
         * @summary List scheduled transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getScheduledTransactions(budget_id: string, options?: any) {
            return ScheduledTransactionsApiFp(configuration).getScheduledTransactions(budget_id, options)();
        },
    };
};

/**
 * ScheduledTransactionsApi - object-oriented interface
 * @export
 * @class ScheduledTransactionsApi
 * @extends {BaseAPI}
 */
export class ScheduledTransactionsApi extends BaseAPI {
    /**
     * Returns a single scheduled transaction
     * @summary Single scheduled transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} scheduled_transaction_id - The ID of the Scheduled Transaction.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    public getScheduledTransactionById(budget_id: string, scheduled_transaction_id: string, options?: any) {
        return ScheduledTransactionsApiFp(this.configuration).getScheduledTransactionById(budget_id, scheduled_transaction_id, options)();
    }

    /**
     * Returns all scheduled transactions
     * @summary List scheduled transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof ScheduledTransactionsApi
     */
    public getScheduledTransactions(budget_id: string, options?: any) {
        return ScheduledTransactionsApiFp(this.configuration).getScheduledTransactions(budget_id, options)();
    }

}

/**
 * TransactionsApi - fetch parameter creator
 * @export
 */
export const TransactionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates multiple transactions
         * @summary Bulk create transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {BulkTransactions} transactions - The list of Transactions to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id: string, transactions: BulkTransactions, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling bulkCreateTransactions.');
            }
            // verify required parameter 'transactions' is not null or undefined
            if (transactions === null || transactions === undefined) {
                throw new RequiredError('transactions','Required parameter transactions was null or undefined when calling bulkCreateTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/bulk`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transactions || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a transaction
         * @summary Create new transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {SaveTransactionWrapper} transaction - The Transaction to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id: string, transaction: SaveTransactionWrapper, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling createTransaction.');
            }
            // verify required parameter 'transaction' is not null or undefined
            if (transaction === null || transaction === undefined) {
                throw new RequiredError('transaction','Required parameter transaction was null or undefined when calling createTransaction.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transaction || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id: string, since_date?: Date | string, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getTransactions.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id: string, account_id: string, since_date?: Date | string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getTransactionsByAccount.');
            }
            // verify required parameter 'account_id' is not null or undefined
            if (account_id === null || account_id === undefined) {
                throw new RequiredError('account_id','Required parameter account_id was null or undefined when calling getTransactionsByAccount.');
            }
            const localVarPath = `/budgets/{budget_id}/accounts/{account_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"account_id"}}`, encodeURIComponent(String(account_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id: string, category_id: string, since_date?: Date | string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getTransactionsByCategory.');
            }
            // verify required parameter 'category_id' is not null or undefined
            if (category_id === null || category_id === undefined) {
                throw new RequiredError('category_id','Required parameter category_id was null or undefined when calling getTransactionsByCategory.');
            }
            const localVarPath = `/budgets/{budget_id}/categories/{category_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"category_id"}}`, encodeURIComponent(String(category_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budget_id: string, transaction_id: string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getTransactionsById.');
            }
            // verify required parameter 'transaction_id' is not null or undefined
            if (transaction_id === null || transaction_id === undefined) {
                throw new RequiredError('transaction_id','Required parameter transaction_id was null or undefined when calling getTransactionsById.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id: string, payee_id: string, since_date?: Date | string, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling getTransactionsByPayee.');
            }
            // verify required parameter 'payee_id' is not null or undefined
            if (payee_id === null || payee_id === undefined) {
                throw new RequiredError('payee_id','Required parameter payee_id was null or undefined when calling getTransactionsByPayee.');
            }
            const localVarPath = `/budgets/{budget_id}/payees/{payee_id}/transactions`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"payee_id"}}`, encodeURIComponent(String(payee_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (since_date !== undefined) {
                localVarQueryParameter['since_date'] = convertDateToFullDateStringFormat(since_date);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {SaveTransactionWrapper} transaction - The Transaction to update.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id: string, transaction_id: string, transaction: SaveTransactionWrapper, options: any = {}): FetchArgs {
            // verify required parameter 'budget_id' is not null or undefined
            if (budget_id === null || budget_id === undefined) {
                throw new RequiredError('budget_id','Required parameter budget_id was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'transaction_id' is not null or undefined
            if (transaction_id === null || transaction_id === undefined) {
                throw new RequiredError('transaction_id','Required parameter transaction_id was null or undefined when calling updateTransaction.');
            }
            // verify required parameter 'transaction' is not null or undefined
            if (transaction === null || transaction === undefined) {
                throw new RequiredError('transaction','Required parameter transaction was null or undefined when calling updateTransaction.');
            }
            const localVarPath = `/budgets/{budget_id}/transactions/{transaction_id}`
                .replace(`{${"budget_id"}}`, encodeURIComponent(String(budget_id)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transaction_id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = JSON.stringify(transaction || {});

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates multiple transactions
         * @summary Bulk create transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {BulkTransactions} transactions - The list of Transactions to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id: string, transactions: BulkTransactions, options?: any): (fetchFunction?: FetchAPI) => Promise<BulkResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).bulkCreateTransactions(budget_id, transactions, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Creates a transaction
         * @summary Create new transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {SaveTransactionWrapper} transaction - The Transaction to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id: string, transaction: SaveTransactionWrapper, options?: any): (fetchFunction?: FetchAPI) => Promise<TransactionResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).createTransaction(budget_id, transaction, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id: string, since_date?: Date | string, type?: string, options?: any): (fetchFunction?: FetchAPI) => Promise<TransactionsResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactions(budget_id, since_date, type, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id: string, account_id: string, since_date?: Date | string, options?: any): (fetchFunction?: FetchAPI) => Promise<TransactionsResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsByAccount(budget_id, account_id, since_date, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id: string, category_id: string, since_date?: Date | string, options?: any): (fetchFunction?: FetchAPI) => Promise<HybridTransactionsResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsByCategory(budget_id, category_id, since_date, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budget_id: string, transaction_id: string, options?: any): (fetchFunction?: FetchAPI) => Promise<TransactionResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsById(budget_id, transaction_id, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id: string, payee_id: string, since_date?: Date | string, options?: any): (fetchFunction?: FetchAPI) => Promise<HybridTransactionsResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).getTransactionsByPayee(budget_id, payee_id, since_date, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {SaveTransactionWrapper} transaction - The Transaction to update.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id: string, transaction_id: string, transaction: SaveTransactionWrapper, options?: any): (fetchFunction?: FetchAPI) => Promise<TransactionResponse> {
            const localVarFetchArgs = TransactionsApiFetchParamCreator(configuration).updateTransaction(budget_id, transaction_id, transaction, options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Creates multiple transactions
         * @summary Bulk create transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {BulkTransactions} transactions - The list of Transactions to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        bulkCreateTransactions(budget_id: string, transactions: BulkTransactions, options?: any) {
            return TransactionsApiFp(configuration).bulkCreateTransactions(budget_id, transactions, options)();
        },
        /**
         * Creates a transaction
         * @summary Create new transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {SaveTransactionWrapper} transaction - The Transaction to create.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        createTransaction(budget_id: string, transaction: SaveTransactionWrapper, options?: any) {
            return TransactionsApiFp(configuration).createTransaction(budget_id, transaction, options)();
        },
        /**
         * Returns budget transactions
         * @summary List transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactions(budget_id: string, since_date?: Date | string, type?: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactions(budget_id, since_date, type, options)();
        },
        /**
         * Returns all transactions for a specified account
         * @summary List account transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} account_id - The ID of the Account.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByAccount(budget_id: string, account_id: string, since_date?: Date | string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsByAccount(budget_id, account_id, since_date, options)();
        },
        /**
         * Returns all transactions for a specified category
         * @summary List category transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} category_id - The ID of the Category.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByCategory(budget_id: string, category_id: string, since_date?: Date | string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsByCategory(budget_id, category_id, since_date, options)();
        },
        /**
         * Returns a single transaction
         * @summary Single transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsById(budget_id: string, transaction_id: string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsById(budget_id, transaction_id, options)();
        },
        /**
         * Returns all transactions for a specified payee
         * @summary List payee transactions
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} payee_id - The ID of the Payee.
         * @param {Date} [since_date] - Only return transactions on or after this date.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getTransactionsByPayee(budget_id: string, payee_id: string, since_date?: Date | string, options?: any) {
            return TransactionsApiFp(configuration).getTransactionsByPayee(budget_id, payee_id, since_date, options)();
        },
        /**
         * Updates a transaction
         * @summary Updates an existing transaction
         * @param {string} budget_id - The ID of the Budget.
         * @param {string} transaction_id - The ID of the Transaction.
         * @param {SaveTransactionWrapper} transaction - The Transaction to update.
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        updateTransaction(budget_id: string, transaction_id: string, transaction: SaveTransactionWrapper, options?: any) {
            return TransactionsApiFp(configuration).updateTransaction(budget_id, transaction_id, transaction, options)();
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Creates multiple transactions
     * @summary Bulk create transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {BulkTransactions} transactions - The list of Transactions to create.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public bulkCreateTransactions(budget_id: string, transactions: BulkTransactions, options?: any) {
        return TransactionsApiFp(this.configuration).bulkCreateTransactions(budget_id, transactions, options)();
    }

    /**
     * Creates a transaction
     * @summary Create new transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {SaveTransactionWrapper} transaction - The Transaction to create.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public createTransaction(budget_id: string, transaction: SaveTransactionWrapper, options?: any) {
        return TransactionsApiFp(this.configuration).createTransaction(budget_id, transaction, options)();
    }

    /**
     * Returns budget transactions
     * @summary List transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {string} [type] - Only return transactions of a certain type (i.e. 'uncategorized', 'unapproved')
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(budget_id: string, since_date?: Date | string, type?: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactions(budget_id, since_date, type, options)();
    }

    /**
     * Returns all transactions for a specified account
     * @summary List account transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} account_id - The ID of the Account.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByAccount(budget_id: string, account_id: string, since_date?: Date | string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsByAccount(budget_id, account_id, since_date, options)();
    }

    /**
     * Returns all transactions for a specified category
     * @summary List category transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} category_id - The ID of the Category.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByCategory(budget_id: string, category_id: string, since_date?: Date | string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsByCategory(budget_id, category_id, since_date, options)();
    }

    /**
     * Returns a single transaction
     * @summary Single transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} transaction_id - The ID of the Transaction.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsById(budget_id: string, transaction_id: string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsById(budget_id, transaction_id, options)();
    }

    /**
     * Returns all transactions for a specified payee
     * @summary List payee transactions
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} payee_id - The ID of the Payee.
     * @param {Date} [since_date] - Only return transactions on or after this date.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionsByPayee(budget_id: string, payee_id: string, since_date?: Date | string, options?: any) {
        return TransactionsApiFp(this.configuration).getTransactionsByPayee(budget_id, payee_id, since_date, options)();
    }

    /**
     * Updates a transaction
     * @summary Updates an existing transaction
     * @param {string} budget_id - The ID of the Budget.
     * @param {string} transaction_id - The ID of the Transaction.
     * @param {SaveTransactionWrapper} transaction - The Transaction to update.
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public updateTransaction(budget_id: string, transaction_id: string, transaction: SaveTransactionWrapper, options?: any) {
        return TransactionsApiFp(this.configuration).updateTransaction(budget_id, transaction_id, transaction, options)();
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns authenticated user information.
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options: any = {}): FetchArgs {
            const localVarPath = `/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["User-Agent"] = USER_AGENT;
            localVarHeaderParameter["Accept"] = "application/json";

            // authentication bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns authenticated user information.
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options?: any): (fetchFunction?: FetchAPI) => Promise<UserResponse> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUser(options);
            return (fetchFunction: FetchAPI = fetch) => {
                return fetchFunction(configuration.basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        return response.json().then((e) => {
                            return Promise.reject(e);
                        });
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration) {
    return {
        /**
         * Returns authenticated user information.
         * @summary User info
         * @param {*} [options] - Override http request options.
         * @throws {RequiredError}
         */
        getUser(options?: any) {
            return UserApiFp(configuration).getUser(options)();
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Returns authenticated user information.
     * @summary User info
     * @param {*} [options] - Override http request options.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(options?: any) {
        return UserApiFp(this.configuration).getUser(options)();
    }

}

